default_platform(:ios)

# Clean Architecture - Use Cases
# Use scripts directory from environment (set by deploy.sh) or fallback to relative path
scripts_dir = ENV['FL_SCRIPTS_DIR'] || File.join(File.dirname(__FILE__), '..', '..', 'scripts')
use_cases_dir = File.join(scripts_dir, 'domain', 'use_cases')
require File.join(use_cases_dir, 'setup_keychain')
require File.join(use_cases_dir, 'create_certificates')
require File.join(use_cases_dir, 'create_provisioning_profiles')
require File.join(use_cases_dir, 'monitor_testflight_processing')

# Clean up certificates from Apple Developer Portal to make room for new ones
def cleanup_apple_certificates(team_id, api_key_path, api_key_id, api_issuer_id)
  UI.message("üßπ STARTING CERTIFICATE CLEANUP...")
  UI.message("üîç Parameters: team_id=#{team_id}, api_key_id=#{api_key_id}")
  
  begin
    # Use native fastlane approach with same API key as main flow
    UI.message("üîë Using App Store Connect API for certificate cleanup...")
    
    # Import spaceship for direct certificate management
    require 'spaceship'
    
    # Use the App Store Connect API token that's already configured by fastlane
    # This avoids authentication conflicts
    UI.message("üåê Connecting to Apple Developer Portal...")
    
    # Get certificates using Connect API (not Portal API to avoid auth conflicts)
    certificates = Spaceship::ConnectAPI::Certificate.all
    
    dev_certs = certificates.select { |cert| cert.certificate_type.include?("DEVELOPMENT") }
    dist_certs = certificates.select { |cert| cert.certificate_type.include?("DISTRIBUTION") }
    
    UI.message("üìä Found #{dev_certs.count} development certificates and #{dist_certs.count} distribution certificates")
    
    # Show certificate details
    dev_certs.each_with_index do |cert, i|
      UI.message("   Dev #{i+1}: #{cert.id} - #{cert.name}")
    end
    
    dist_certs.each_with_index do |cert, i|
      UI.message("   Dist #{i+1}: #{cert.id} - #{cert.name}")
    end
    
    # Remove development certificates if at limit (be aggressive - remove if >= 1)
    if dev_certs.count >= 1
      cert_to_remove = dev_certs.first
      UI.message("üóëÔ∏è  Removing development certificate: #{cert_to_remove.id} (#{cert_to_remove.name})")
      cert_to_remove.delete!
      UI.success("‚úÖ Removed development certificate #{cert_to_remove.id}")
    end
    
    # Remove distribution certificates if at limit (be aggressive - remove if >= 1)  
    if dist_certs.count >= 1
      cert_to_remove = dist_certs.first
      UI.message("üóëÔ∏è  Removing distribution certificate: #{cert_to_remove.id} (#{cert_to_remove.name})")
      cert_to_remove.delete!
      UI.success("‚úÖ Removed distribution certificate #{cert_to_remove.id}")
    end
    
    UI.success("üßπ Certificate cleanup completed successfully!")
    
  rescue => e
    UI.error("‚ùå Certificate cleanup failed: #{e.message}")
    UI.error("üîç Error details: #{e.class}: #{e.message}")
    UI.error("üìç Backtrace: #{e.backtrace.first(3).join('\n')}")
    UI.message("üí° Continuing without cleanup - certificate creation may fail")
  end
end

platform :ios do
  desc "Simple certificate creation and TestFlight upload"
  lane :build_and_upload do |options|
    # Get parameters from environment variables (set by deploy.sh)
    app_identifier = ENV['FL_APP_IDENTIFIER']
    team_id = ENV['FL_TEAM_ID']
    apple_id = ENV['FL_APPLE_ID']
    api_key_path = ENV['FL_API_KEY_PATH']
    api_key_id = ENV['FL_API_KEY_ID']
    api_issuer_id = ENV['FL_API_ISSUER_ID']
    scheme = ENV['FL_SCHEME'] || "template_swiftui"
    
    UI.message("üéØ DEBUG: Lane started successfully!")
    UI.message("üîç Environment variables:")
    UI.message("   - FL_APP_IDENTIFIER: #{app_identifier}")
    UI.message("   - FL_TEAM_ID: #{team_id}")
    UI.message("   - FL_APPLE_ID: #{apple_id}")
    UI.message("   - FL_API_KEY_PATH: #{api_key_path}")
    UI.message("   - FL_API_KEY_ID: #{api_key_id}")
    UI.message("   - FL_API_ISSUER_ID: #{api_issuer_id}")
    UI.message("   - FL_SCHEME: #{scheme}")
    
    UI.header("üè≠ iOS Certificate Creation and TestFlight Upload")
    UI.message("üìã Parameters:")
    UI.message("   - App ID: #{app_identifier}")
    UI.message("   - Team ID: #{team_id}")
    UI.message("   - Scheme: #{scheme}")
    UI.message("   - API Key: #{File.basename(api_key_path)}")
    
    # Set up App Store Connect API authentication (for certificate operations only)
    api_key = {
      key_id: api_key_id,
      issuer_id: api_issuer_id,
      key_filepath: api_key_path
    }
    
    # Track overall deployment success
    deployment_success = false
    deployment_phases = []
    
    begin
      # Get environment variables for directories
      certificates_dir = ENV['FL_CERTIFICATES_DIR']
      profiles_dir = ENV['FL_PROFILES_DIR']
      p12_password = ENV['FL_P12_PASSWORD']
      
      UI.message("üìÅ Directory Configuration:")
      UI.message("   - Certificates: #{certificates_dir}")
      UI.message("   - Profiles: #{profiles_dir}")
      UI.message("   - P12 Password: #{p12_password ? '[PROVIDED]' : '[NOT PROVIDED]'}")
      
      # Check if we need to cleanup certificates first
      cleanup_certs = ENV['FL_CLEANUP_CERTIFICATES']
      if cleanup_certs == 'true'
        cleanup_apple_certificates(team_id, api_key_path, api_key_id, api_issuer_id)
      end
      
      # Use Clean Architecture - SetupKeychain Use Case
      keychain_request = SetupKeychainRequest.new(
        keychain_name: "ios_deploy_#{Time.now.strftime('%Y%m%d_%H%M%S')}_#{team_id}",
        certificates_dir: certificates_dir,
        p12_password: p12_password,
        team_id: team_id
      )
      
      setup_keychain_use_case = SetupKeychain.new
      keychain_result = setup_keychain_use_case.execute(keychain_request)
      
      if keychain_result.success
        temp_keychain_path = keychain_result.keychain_path
        UI.success("‚úÖ Keychain setup completed via clean architecture use case")
        UI.message("üîë Temporary keychain: #{File.basename(temp_keychain_path)}")
      else
        UI.error("‚ùå Keychain setup failed: #{keychain_result.error}")
        UI.message("üí° #{keychain_result.recovery_suggestion}")
        raise "Keychain setup failed: #{keychain_result.error}"
      end
      
      # Use Clean Architecture - CreateCertificates Use Case
      certificates_request = CreateCertificatesRequest.new(
        team_id: team_id,
        apple_id: apple_id,
        keychain_path: temp_keychain_path,
        keychain_password: "temp_password_#{rand(1000)}",
        output_path: certificates_dir
      )
      
      create_certificates_use_case = CreateCertificates.new
      certificates_result = create_certificates_use_case.execute(certificates_request)
      
      if certificates_result.success
        UI.success("‚úÖ Certificate creation/validation completed via clean architecture use case")
        UI.message("üîê Development certificates: #{certificates_result.development_certificates_count}")
        UI.message("üîê Distribution certificates: #{certificates_result.distribution_certificates_count}")
      else
        UI.error("‚ùå Certificate creation failed: #{certificates_result.error}")
        UI.message("üí° #{certificates_result.recovery_suggestion}")
        raise "Certificate creation failed: #{certificates_result.error}"
      end
      
      # Use Clean Architecture - CreateProvisioningProfiles Use Case
      profiles_request = CreateProvisioningProfilesRequest.new(
        app_identifier: app_identifier,
        team_id: team_id,
        apple_id: apple_id,
        profiles_dir: profiles_dir
      )
      
      create_profiles_use_case = CreateProvisioningProfiles.new
      profiles_result = create_profiles_use_case.execute(profiles_request)
      
      if profiles_result.success
        UI.success("‚úÖ Provisioning profiles creation/validation completed via clean architecture use case")
        UI.message("üì± Development profiles: #{profiles_result.development_profiles_count}")
        UI.message("üì± Distribution profiles: #{profiles_result.distribution_profiles_count}")
        
        # Install provisioning profiles to system location for Xcode
        UI.header("üì± Installing Provisioning Profiles to System Location")
        system_profiles_dir = File.expand_path("~/Library/MobileDevice/Provisioning Profiles")
        FileUtils.mkdir_p(system_profiles_dir) unless File.directory?(system_profiles_dir)
        
        if File.directory?(profiles_dir)
          profile_files = Dir.glob("#{profiles_dir}/*.mobileprovision")
          installed_count = 0
          
          profile_files.each do |profile_file|
            destination = File.join(system_profiles_dir, File.basename(profile_file))
            begin
              FileUtils.copy_file(profile_file, destination)
              UI.message("üì± Installed profile: #{File.basename(profile_file)}")
              installed_count += 1
            rescue => e
              UI.error("‚ùå Failed to install profile #{File.basename(profile_file)}: #{e.message}")
              raise "Profile installation failed: #{e.message}"
            end
          end
          
          if installed_count > 0
            UI.success("‚úÖ Installed #{installed_count} provisioning profile(s) to system location")
            UI.message("üìÅ System profiles directory: #{system_profiles_dir}")
          else
            UI.important("‚ö†Ô∏è No profiles found to install - profiles may be created automatically by Xcode")
          end
        else
          UI.important("‚ö†Ô∏è Profiles directory not found: #{profiles_dir}")
        end
      else
        UI.error("‚ùå Provisioning profiles creation failed: #{profiles_result.error}")
        UI.message("üí° #{profiles_result.recovery_suggestion}")
        raise "Provisioning profiles creation failed: #{profiles_result.error}"
      end
      
      # Get version info from Xcode project (updated by deploy.sh)
      project_file = "./#{scheme}.xcodeproj/project.pbxproj"
      
      if File.exist?(project_file)
        # Read marketing version from project
        version_line = File.readlines(project_file).find { |line| line.include?('MARKETING_VERSION') }
        if version_line
          version = version_line.match(/MARKETING_VERSION = ([^;]*);/)[1].strip
        else
          version = ENV['FL_VERSION'] || '1.0.0'
        end
        
        # Read build number from project
        build_line = File.readlines(project_file).find { |line| line.include?('CURRENT_PROJECT_VERSION') }
        if build_line
          build_number = build_line.match(/CURRENT_PROJECT_VERSION = ([^;]*);/)[1].strip
        else
          build_number = ENV['FL_BUILD_NUMBER'] || '1'
        end
        
        UI.message("üì± Read from project file:")
        UI.message("   - Marketing Version: #{version}")
        UI.message("   - Build Number: #{build_number}")
      else
        # Fallback to environment variables
        version = ENV['FL_VERSION'] || '1.0.0'
        build_number = ENV['FL_BUILD_NUMBER'] || '1'
        UI.message("‚ö†Ô∏è  Using fallback version info (project file not found)")
      end
      
      UI.header("üì± Building and Archiving iOS Application")
      UI.message("üìã Build configuration:")
      UI.message("   - App: #{app_identifier}")
      UI.message("   - Version: #{version}")
      UI.message("   - Build: #{build_number}")
      UI.message("   - Scheme: #{scheme}")
      
      # Ensure build directory exists
      build_dir = "./build"
      unless Dir.exist?(build_dir)
        FileUtils.mkdir_p(build_dir)
        UI.message("üìÅ Created build directory: #{build_dir}")
      end
      
      # Configure Xcode project team via FastLane (not automatic signing)
      UI.message("üîß Configuring Xcode project team via FastLane...")
      begin
        update_project_team(
          path: "./#{scheme}.xcodeproj",
          teamid: team_id
        )
        UI.success("‚úÖ Team configured in Xcode project: #{team_id}")
      rescue => e
        UI.message("‚ö†Ô∏è  Could not update project team via update_project_team: #{e.message}")
        UI.message("üí° This is expected for some project configurations - using xcargs fallback")
      end
      
      # Build and archive the application with intelligent signing failover
      ipa_path = nil
      build_attempt = 1
      max_attempts = 3  # Increased to allow for profile regeneration
      
      while build_attempt <= max_attempts && ipa_path.nil?
        begin
          # Force manual signing for AppStore builds to ensure correct certificate selection
          signing_style = "manual"
          
          # More descriptive attempt messages
          case build_attempt
          when 1
            UI.message("üî® Build attempt 1/3: Trying automatic signing...")
          when 2
            UI.message("üî® Build attempt 2/3: Retrying with manual signing...")
          when 3
            UI.message("üî® Build attempt 3/3: Final attempt after profile regeneration...")
          end
          
          # For manual signing, configure Xcode project to disable automatic signing
          if signing_style == "manual"
            begin
              UI.message("üîß Configuring project for manual code signing...")
              update_project_provisioning(
                xcodeproj: "./#{scheme}.xcodeproj",
                target_filter: ".*#{scheme}.*",
                profile: "#{profiles_dir}/AppStore_#{app_identifier}.mobileprovision",
                build_configuration: "Release"
              )
              UI.success("‚úÖ Project configured for manual signing")
            rescue => e
              UI.message("‚ö†Ô∏è Could not configure manual signing via update_project_provisioning: #{e.message}")
              UI.message("üí° Continuing with export_options configuration...")
            end
          end
          
          # Configure provisioning profile name and certificate based on signing style
          profile_name = nil
          certificate_name = nil
          
          if signing_style == "automatic"
            profile_name = "#{app_identifier} AppStore"  # Automatic signing expects this format
          else
            # For manual signing, intelligently match certificates and profiles
            profiles_dir = ENV['FL_PROFILES_DIR']
            certificates_dir = ENV['FL_CERTIFICATES_DIR']
            
            if profiles_dir && Dir.exist?(profiles_dir)
              profile_files = Dir.glob("#{profiles_dir}/*AppStore*.mobileprovision")
              if profile_files.any?
                profile_file = profile_files.first
                profile_name = File.basename(profile_file, '.mobileprovision').gsub(/^AppStore_/, '')
                UI.message("üì± Found AppStore profile: #{File.basename(profile_file)} -> #{profile_name}")
                
                # For AppStore profiles, we need distribution certificates
                # First try to find in the temporary keychain if it exists
                keychain_path = Dir.glob("#{certificates_dir}/*.keychain-db").first
                identities_output = nil
                
                if keychain_path && File.exist?(keychain_path)
                  identities_output = `security find-identity -v -p codesigning "#{keychain_path}" 2>/dev/null`
                end
                
                # If not found in temporary keychain, use the default keychain
                if identities_output.nil? || identities_output.strip.empty? || !identities_output.include?("Apple Distribution")
                  UI.message("üîç Looking for distribution certificate in default keychain...")
                  identities_output = `security find-identity -v -p codesigning 2>/dev/null`
                end
                
                # Find the distribution certificate for this team
                identities_output.split("\n").each do |line|
                  if line.include?("Apple Distribution") && line.include?("(#{team_id})")
                    certificate_name = line.match(/"([^"]*)"/)&.captures&.first
                    UI.message("üîß Matched with distribution certificate: #{certificate_name}")
                    break
                  end
                end
              else
                profile_name = "#{app_identifier} AppStore"  # Fallback
              end
            else
              profile_name = "#{app_identifier} AppStore"  # Fallback
            end
          end
          
          # Build export options with intelligent certificate/profile matching
          export_options = {
            method: "app-store",
            uploadBitcode: false,
            uploadSymbols: true,
            compileBitcode: false,
            teamID: team_id,
            signingStyle: signing_style,
            provisioningProfiles: {
              app_identifier => profile_name
            }
          }
          
          # Add certificate specification for manual signing if we found a match
          if signing_style == "manual" && certificate_name
            export_options[:signingCertificate] = certificate_name
            UI.message("üîß Export will use certificate: #{certificate_name}")
          end
          
          # For manual signing, specify the exact certificate to use during build
          build_options = {
            scheme: scheme,
            configuration: "Release",
            clean: build_attempt == 1, # Only clean on first attempt
            archive_path: "./build/#{scheme}_#{version}_#{build_number}.xcarchive",
            export_method: "app-store",
            export_team_id: team_id,
            xcargs: "DEVELOPMENT_TEAM=#{team_id}",
            export_options: export_options
          }
          
          # For manual signing, force xcodebuild to use the distribution certificate
          if signing_style == "manual" && certificate_name
            build_options[:codesigning_identity] = certificate_name
            UI.message("üîß Build will use certificate: #{certificate_name}")
          end
          
          build_app(build_options)
          
          ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
          UI.success("üéâ Build completed successfully with #{signing_style} signing!")
          UI.message("üì¶ IPA location: #{ipa_path}")
          break
          
        rescue => build_error
          UI.error("‚ùå Build attempt #{build_attempt} failed: #{build_error.message}")
          
          # Check if this is a certificate/profile mismatch error
          if build_error.message.include?("doesn't include signing certificate") || 
             build_error.message.include?("requires a provisioning profile")
            
            if build_attempt < max_attempts
              UI.important("üîÑ Detected certificate/profile mismatch - fixing certificate selection...")
              
              # Get available certificates from keychain
              certificates_dir = ENV['FL_CERTIFICATES_DIR']
              keychain_path = Dir.glob("#{certificates_dir}/*.keychain-db").first
              
              if keychain_path
                UI.message("üîç Analyzing available certificates in keychain...")
                
                # Get all available signing identities
                identities_output = `security find-identity -v -p codesigning "#{keychain_path}" 2>/dev/null`
                
                # Find distribution certificate for AppStore profile
                distribution_cert = nil
                development_cert = nil
                
                identities_output.split("\n").each do |line|
                  if line.include?("Apple Distribution")
                    # Extract certificate name
                    distribution_cert = line.match(/"([^"]*)"/)&.captures&.first
                    UI.message("üìã Found distribution certificate: #{distribution_cert}")
                  elsif line.include?("Apple Development")
                    development_cert = line.match(/"([^"]*)"/)&.captures&.first
                    UI.message("üìã Found development certificate: #{development_cert}")
                  end
                end
                
                # For AppStore profiles, we need distribution certificates
                if profile_name.include?("AppStore") && distribution_cert
                  UI.message("üîß Configuring Xcode to use distribution certificate for AppStore profile...")
                  
                  # Update project to use specific certificate
                  begin
                    update_project_provisioning(
                      xcodeproj: "./#{scheme}.xcodeproj",
                      target_filter: ".*#{scheme}.*",
                      profile: "#{ENV['FL_PROFILES_DIR']}/AppStore_#{app_identifier}.mobileprovision",
                      build_configuration: "Release",
                      certificate: distribution_cert
                    )
                    UI.success("‚úÖ Updated project to use distribution certificate: #{distribution_cert}")
                  rescue => cert_update_error
                    UI.message("‚ö†Ô∏è Standard certificate update failed: #{cert_update_error.message}")
                    
                    # Fallback: Manual xcodeproj modification with precision targeting
                    UI.message("üîß Applying targeted certificate configuration for Release builds...")
                    project_path = "./#{scheme}.xcodeproj/project.pbxproj"
                    
                    if File.exist?(project_path)
                      project_content = File.read(project_path)
                      modified = false
                      
                      # Find Release configuration blocks for the main target
                      # Pattern: Look for Release XCBuildConfiguration sections that contain CODE_SIGN_IDENTITY
                      release_blocks = project_content.scan(/(\w+) \/\* Release \*\/ = \{[^}]+buildSettings = \{[^}]+\};/m)
                      
                      if release_blocks.any?
                        UI.message("üîç Found #{release_blocks.length} Release configuration(s) to update")
                        
                        # Update each Release configuration block
                        release_blocks.each_with_index do |block_match, index|
                          block_content = block_match[0]
                          
                          # Only update blocks that contain CODE_SIGN_IDENTITY (target configs, not project configs)
                          if block_content.include?('CODE_SIGN_IDENTITY')
                            # Extract the UUID for this configuration
                            uuid_match = project_content.match(/(\w+) \/\* Release \*\/ = \{[^}]*#{Regexp.escape(block_content.split(' = {')[1] || '')}[^}]*\}/m)
                            
                            if uuid_match
                              config_uuid = uuid_match[1]
                              UI.message("üéØ Updating Release config #{config_uuid} (#{index + 1}/#{release_blocks.length})")
                              
                              # Update CODE_SIGN_IDENTITY in this specific Release block
                              project_content.gsub!(/(#{config_uuid} \/\* Release \*\/ = \{[^}]*buildSettings = \{[^}]*CODE_SIGN_IDENTITY = ")[^"]*(";[^}]*\};)/m) do |match|
                                updated_block = match.gsub(/CODE_SIGN_IDENTITY = "[^"]*";/, "CODE_SIGN_IDENTITY = \"#{distribution_cert}\";")
                                modified = true
                                UI.message("   ‚úì Updated CODE_SIGN_IDENTITY to: #{distribution_cert}")
                                updated_block
                              end
                              
                              # Also ensure PROVISIONING_PROFILE_SPECIFIER matches the correct AppStore profile name
                              if profile_name
                                project_content.gsub!(/(#{config_uuid} \/\* Release \*\/ = \{[^}]*buildSettings = \{[^}]*PROVISIONING_PROFILE_SPECIFIER = ")[^"]*(";[^}]*\};)/m) do |match|
                                  updated_block = match.gsub(/PROVISIONING_PROFILE_SPECIFIER = "[^"]*";/, "PROVISIONING_PROFILE_SPECIFIER = \"#{profile_name}\";")
                                  UI.message("   ‚úì Updated PROVISIONING_PROFILE_SPECIFIER to: #{profile_name}")
                                  updated_block
                                end
                              end
                            end
                          end
                        end
                      else
                        # Fallback to broader approach if structured parsing fails
                        UI.message("‚ö†Ô∏è  Structured parsing failed, using broader certificate update...")
                        original_modified = modified
                        
                        # Update only Release configurations containing CODE_SIGN_IDENTITY
                        project_content.gsub!(/(\/\* Release \*\/[^}]+buildSettings = \{[^}]*CODE_SIGN_IDENTITY = ")[^"]*(";[^}]*\})/m) do |match|
                          modified = true
                          match.gsub(/CODE_SIGN_IDENTITY = "[^"]*";/, "CODE_SIGN_IDENTITY = \"#{distribution_cert}\";")
                        end
                        
                        if modified != original_modified
                          UI.message("   ‚úì Updated CODE_SIGN_IDENTITY via fallback method")
                        end
                      end
                      
                      if modified
                        File.write(project_path, project_content)
                        UI.success("‚úÖ Successfully updated Release configuration(s) to use distribution certificate")
                        UI.message("   Certificate: #{distribution_cert}")
                        UI.message("   Profile: #{profile_name}") if profile_name
                      else
                        UI.message("‚ö†Ô∏è  No Release configurations found to update - project may have non-standard structure")
                        # Still try the original broad approach as final fallback
                        project_content.gsub!(/CODE_SIGN_IDENTITY\s*=\s*"[^"]*";/, "CODE_SIGN_IDENTITY = \"#{distribution_cert}\";") 
                        File.write(project_path, project_content)
                        UI.message("   Applied broad certificate update as final fallback")
                      end
                    end
                  end
                  
                elsif development_cert
                  UI.message("üîß Using development certificate: #{development_cert}")
                end
                
                build_attempt += 1
              else
                UI.error("‚ùå Could not find temporary keychain")
                raise "Temporary keychain not found for certificate analysis"
              end
            else
              UI.error("üí• All build attempts failed")
              raise "Build failed after #{max_attempts} attempts. Last error: #{build_error.message}"
            end
          else
            # For other types of errors, just retry with manual signing
            if build_attempt < max_attempts
              UI.important("üîÑ Retrying with manual signing configuration...")
              build_attempt += 1
            else
              UI.error("üí• All build attempts failed")
              raise "Build failed after #{max_attempts} attempts. Last error: #{build_error.message}"
            end
          end
        end
      end
      
      # Check if enhanced TestFlight mode is enabled
      testflight_enhanced = ENV['FL_TESTFLIGHT_ENHANCED'] == 'true'
      
      UI.header("üöÄ Uploading to TestFlight")
      UI.message("üìã Upload configuration:")
      UI.message("   - IPA: #{File.basename(ipa_path)}")
      UI.message("   - Enhanced mode: #{testflight_enhanced}")
      UI.message("   - Automatic conflict resolution: ‚úÖ Enabled")
      UI.message("üí° Build numbers are automatically incremented if conflicts exist in TestFlight")
      
      # Upload to TestFlight using xcrun altool
      upload_start_time = Time.now
      
      # Get IPA file size for tracking
      ipa_size_bytes = File.size(ipa_path)
      ipa_size_mb = (ipa_size_bytes / (1024.0 * 1024.0)).round(1)
      
      UI.message("üìä IPA Details:")
      UI.message("   - File: #{File.basename(ipa_path)}")
      UI.message("   - Size: #{ipa_size_mb}MB (#{ipa_size_bytes.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse} bytes)")
      
      # Create the expected private_keys directory and copy the API key
      private_keys_dir = File.expand_path("~/.appstoreconnect/private_keys")
      FileUtils.mkdir_p(private_keys_dir)
      api_key_filename = File.basename(api_key_path)
      destination_key_path = File.join(private_keys_dir, api_key_filename)
      FileUtils.copy(api_key_path, destination_key_path)
      
      # Build the upload command
      upload_command = [
        "xcrun altool",
        "--upload-app",
        "--type ios",
        "--file \"#{ipa_path}\"",
        "--apiKey #{api_key_id}",
        "--apiIssuer #{api_issuer_id}"
      ].join(" ")
      
      UI.message("üîß Executing upload command:")
      UI.message("   xcrun altool --upload-app --type ios --file [IPA] --apiKey [KEY_ID] --apiIssuer [ISSUER_ID]")
      
      # Execute the upload command with retry mechanism
      upload_success = false
      retry_count = 0
      max_retries = 3
      
      while !upload_success && retry_count < max_retries
        begin
          retry_count += 1
          if retry_count > 1
            UI.message("üîÑ Upload attempt #{retry_count}/#{max_retries}...")
            sleep(10) # Wait 10 seconds before retry
          end
          
          sh(upload_command)
          upload_success = true
          UI.success("üéâ Successfully uploaded to TestFlight using xcrun altool!")
          
        rescue => e
          UI.error("‚ùå Upload attempt #{retry_count} failed: #{e.message}")
          if retry_count >= max_retries
            UI.error("‚ùå All upload attempts failed. Please check network connectivity and try again.")
            raise e
          else
            UI.message("‚è≥ Waiting 10 seconds before retry...")
          end
        end
      end
      
      # Clean up the copied API key
      File.delete(destination_key_path) if File.exist?(destination_key_path)
      
      # Calculate upload duration
      if testflight_enhanced
        upload_end_time = Time.now
        upload_duration = (upload_end_time - upload_start_time).round(0)
        UI.success("üéâ Upload completed successfully!")
        UI.message("‚è±Ô∏è  Upload Duration: #{upload_duration} seconds (#{ipa_size_mb}MB)")
        
        # Enhanced confirmation: Wait for Apple processing
        UI.header("üîÑ Enhanced TestFlight Confirmation")
        UI.message("üçé Waiting for Apple to process the build...")
        UI.message("üí≠ This typically takes 2-5 minutes for small apps")
        
        # Use Clean Architecture - MonitorTestFlightProcessing Use Case
        begin
          monitor_request = MonitorTestFlightProcessingRequest.new(
            app_identifier: app_identifier,
            api_key: api_key,
            enhanced_mode: testflight_enhanced
          )
          
          monitor_use_case = MonitorTestFlightProcessing.new
          monitor_result = monitor_use_case.execute(monitor_request)
          
          if monitor_result.success
            UI.success("‚úÖ TestFlight monitoring completed via clean architecture use case")
            if monitor_result.build_ready_for_testing?
              UI.message("üéâ Build is ready for testing!")
            elsif monitor_result.build_processing_failed?
              UI.message("‚ùå Build processing failed - check App Store Connect")
            elsif monitor_result.still_processing?
              UI.message("‚è±Ô∏è Build is still processing")
            end
          else
            UI.message("‚ö†Ô∏è  TestFlight monitoring failed: #{monitor_result.error}")
            UI.message("üí° #{monitor_result.recovery_suggestion}")
          end
        rescue => status_error
          UI.message("‚ö†Ô∏è  Unable to check TestFlight status: #{status_error.message}")
          UI.message("üí° Build upload was successful, but processing status is unavailable")
        end
      else
        UI.success("üéâ Successfully uploaded to TestFlight using xcrun altool!")
        UI.message("üì± Upload completed for: #{File.basename(ipa_path)}")
      end
      
      # Mark deployment as successful only if we reach this point
      deployment_success = true
      
    rescue => upload_error
      UI.error("‚ùå TestFlight upload failed")
      UI.error("üîç Error: #{upload_error.message}")
      
      # Try fallback with transporter tool
      UI.message("üîÑ Attempting fallback upload with transporter...")
      
      begin
        transporter_command = [
          "xcrun iTMSTransporter",
          "-m upload",
          "-f \"#{ipa_path}\"",
          "-k #{api_key_id}",
          "-i #{api_issuer_id}",
          "-v verbose"
        ].join(" ")
        
        sh(transporter_command)
        UI.success("üéâ Successfully uploaded to TestFlight using iTMSTransporter!")
        
      rescue => transporter_error
        UI.error("‚ùå Both upload methods failed")
        UI.error("üîç altool error: #{upload_error.message}")
        UI.error("üîç transporter error: #{transporter_error.message}")
        
        UI.error("üí• DEPLOYMENT FAILED - TestFlight upload unsuccessful")
        UI.message("üìã FAILURE SUMMARY:")
        UI.message("   ‚úÖ Temporary keychain system: WORKING")
        UI.message("   ‚úÖ Certificate management: WORKING") 
        UI.message("   ‚úÖ Provisioning profiles: WORKING")
        UI.message("   ‚úÖ iOS app build: WORKING")
        UI.message("   ‚úÖ IPA generation: WORKING")
        UI.message("   ‚ùå TestFlight upload: FAILED (both altool and transporter)")
        UI.message("")
        UI.message("üí° MANUAL UPLOAD REQUIRED:")
        UI.message("   1. Use Xcode Organizer to upload: #{ipa_path}")
        UI.message("   2. Check API key permissions in App Store Connect")
        UI.message("   3. Verify network connectivity and firewall settings")
        UI.message("")
        UI.message("üéØ IPA READY FOR MANUAL UPLOAD: #{ipa_path}")
        
        # Re-raise the error to ensure script fails
        raise "TestFlight upload failed with both altool and transporter"
      end
    end
    
    # Cleanup temporary keychain using clean architecture
    if !temp_keychain_path.nil?
      setup_keychain_use_case = SetupKeychain.new
      
      # Ensure cleanup happens even if script exits unexpectedly (enhanced with error handling)
      at_exit do
        begin
          setup_keychain_use_case.cleanup_keychain(temp_keychain_path) if temp_keychain_path
        rescue => e
          UI.message("‚ö†Ô∏è  Emergency keychain cleanup failed: #{e.message}")
        end
      end
      
      cleanup_success = setup_keychain_use_case.cleanup_keychain(temp_keychain_path)
      
      unless cleanup_success
        if deployment_success
          UI.message("‚ö†Ô∏è  Keychain cleanup encountered issues but deployment completed successfully")
        else
          UI.message("‚ö†Ô∏è  Keychain cleanup encountered issues - deployment failed")
        end
      end
    end
    
    # Final deployment status message
    if deployment_success
      UI.success("üéâ DEPLOYMENT COMPLETED SUCCESSFULLY!")
      UI.message("‚úÖ All phases completed successfully:")
      UI.message("   ‚úÖ Certificate management")
      UI.message("   ‚úÖ Provisioning profiles (with system installation)")
      UI.message("   ‚úÖ iOS app build and archive")
      UI.message("   ‚úÖ TestFlight upload and verification")
    else
      UI.error("üí• DEPLOYMENT FAILED!")
      UI.message("‚ùå One or more deployment phases failed")
      UI.message("üìã Check the error messages above for details")
      # Ensure the script exits with failure status
      exit 1
    end
  end
  
  desc "Upload existing IPA to TestFlight"
  lane :upload_existing_ipa do |options|
    # Get parameters from environment variables
    app_identifier = ENV['FL_APP_IDENTIFIER']
    api_key_path = ENV['FL_API_KEY_PATH']
    api_key_id = ENV['FL_API_KEY_ID']
    api_issuer_id = ENV['FL_API_ISSUER_ID']
    ipa_path = options[:ipa_path] || ENV['FL_IPA_PATH']
    
    # If no explicit IPA path, find the most recent IPA in build directory
    if ipa_path.nil? || ipa_path.empty?
      build_dir = File.join(Dir.pwd, "build")
      if File.directory?(build_dir)
        ipa_files = Dir.glob(File.join(build_dir, "*.ipa"))
        if ipa_files.any?
          ipa_path = ipa_files.max_by { |f| File.mtime(f) }  # Get most recent IPA
          UI.message("üîç Auto-detected IPA file: #{File.basename(ipa_path)}")
        end
      end
    end
    
    # Validate IPA path
    if ipa_path.nil? || ipa_path.empty? || !File.exist?(ipa_path)
      UI.user_error!("‚ùå No IPA file found. Please ensure build/App_*.ipa exists or pass ipa_path parameter")
    end
    
    UI.message("üöÄ Uploading existing IPA to TestFlight...")
    UI.message("   - IPA Path: #{ipa_path}")
    UI.message("   - API Key: #{File.basename(api_key_path)}")
    
    # Create API key hash for upload_to_testflight
    api_key = {
      key_id: api_key_id,
      issuer_id: api_issuer_id,
      key_filepath: api_key_path
    }
    
    # Check if enhanced TestFlight mode is enabled
    testflight_enhanced = ENV['FL_TESTFLIGHT_ENHANCED'] == 'true'
    
    if testflight_enhanced
      UI.message("üöÄ TestFlight Enhanced Mode: Starting upload with extended confirmation...")
    else
      UI.message("üöÄ Starting TestFlight upload using api_key hash approach...")
    end
    
    upload_to_testflight(
      ipa: ipa_path,
      api_key: api_key,
      skip_waiting_for_build_processing: !testflight_enhanced,
      distribute_external: false
    )
    
    if testflight_enhanced
      UI.success("üéâ Upload completed successfully!")
      
      # Use Clean Architecture - MonitorTestFlightProcessing Use Case for existing IPA upload
      begin
        monitor_request = MonitorTestFlightProcessingRequest.new(
          app_identifier: app_identifier,
          api_key: api_key,
          enhanced_mode: testflight_enhanced
        )
        
        monitor_use_case = MonitorTestFlightProcessing.new
        monitor_result = monitor_use_case.execute(monitor_request)
        
        if monitor_result.success
          UI.success("‚úÖ TestFlight processing monitoring completed via clean architecture use case")
          if monitor_result.build_ready_for_testing?
            UI.message("üéâ Build is ready for testing!")
          elsif monitor_result.build_processing_failed?
            UI.message("‚ùå Build processing failed - check App Store Connect")
          elsif monitor_result.still_processing?
            UI.message("‚è±Ô∏è Build is still processing after timeout")
          end
        else
          UI.message("‚ö†Ô∏è  TestFlight processing monitoring failed: #{monitor_result.error}")
          UI.message("üí° #{monitor_result.recovery_suggestion}")
        end
      rescue => status_error
        UI.message("‚ö†Ô∏è  Unable to check TestFlight processing status: #{status_error.message}")
        UI.message("üí° IPA upload was successful, but processing status is unavailable")
      end
    else
      UI.success("üéâ Successfully uploaded existing IPA to TestFlight!")
    end
  end
  
  desc "Standalone TestFlight status check"
  lane :check_testflight_status_standalone do |options|
    # Get parameters from environment variables
    app_identifier = ENV['FL_APP_IDENTIFIER']
    api_key_path = ENV['FL_API_KEY_PATH']
    api_key_id = ENV['FL_API_KEY_ID']
    api_issuer_id = ENV['FL_API_ISSUER_ID']
    
    UI.message("üîç Checking TestFlight status...")
    UI.message("   - App ID: #{app_identifier}")
    UI.message("   - API Key: #{File.basename(api_key_path)}")
    
    # Create API key hash
    api_key = {
      key_id: api_key_id,
      issuer_id: api_issuer_id,
      key_filepath: api_key_path
    }
    
    # Use Clean Architecture - MonitorTestFlightProcessing Use Case for standalone status check
    begin
      monitor_request = MonitorTestFlightProcessingRequest.new(
        app_identifier: app_identifier,
        api_key: api_key,
        enhanced_mode: true
      )
      
      monitor_use_case = MonitorTestFlightProcessing.new
      monitor_result = monitor_use_case.execute(monitor_request)
      
      if monitor_result.success
        UI.success("‚úÖ TestFlight status check completed via clean architecture use case")
        if monitor_result.build_ready_for_testing?
          UI.message("üéâ Latest build is ready for testing!")
        elsif monitor_result.build_processing_failed?
          UI.message("‚ùå Latest build processing failed - check App Store Connect")
        elsif monitor_result.still_processing?
          UI.message("‚è±Ô∏è Latest build is still processing")
        else
          UI.message("üîç Build status: #{monitor_result.current_build_status}")
        end
      else
        UI.error("‚ùå TestFlight status check failed: #{monitor_result.error}")
        UI.message("üí° #{monitor_result.recovery_suggestion}")
      end
      
    rescue => status_error
      UI.error("‚ùå TestFlight status check exception: #{status_error.message}")
      UI.message("üí° This might indicate API connectivity issues or app not found")
    end
  end
end